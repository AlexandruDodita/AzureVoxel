#include "../headers/block.h"
#include <iostream>
#include <glm/gtc/type_ptr.hpp> // For glm::value_ptr

// Vertex shader source code
const char* vertexShaderSource = R"(
    #version 330 core
    layout (location = 0) in vec3 aPos;
    layout (location = 1) in vec2 aTexCoord;
    
    uniform mat4 model;
    uniform mat4 view;
    uniform mat4 projection;
    
    out vec2 TexCoord;
    
    void main() {
        gl_Position = projection * view * model * vec4(aPos, 1.0);
        TexCoord = aTexCoord;
    }
)";

// Fragment shader source code
const char* fragmentShaderSource = R"(
    #version 330 core
    out vec4 FragColor;
    
    in vec2 TexCoord;
    
    uniform vec3 blockColor; // Keep for potential future use without textures
    uniform sampler2D blockTexture;
    uniform bool useTexture;
    
    void main() {
        if (useTexture) {
            FragColor = texture(blockTexture, TexCoord);
        } else {
            // Fallback color if no texture (can use blockColor uniform)
             FragColor = vec4(blockColor, 1.0);
            // vec3 defaultColor = vec3(0.5, 0.5, 0.5); // Gray fallback
            // FragColor = vec4(defaultColor, 1.0);
        }
    }
)";

Block::Block(const glm::vec3& position, const glm::vec3& color, float size)
    : position(position), color(color), size(size) 
      // Other members initialized in header (C++11 onwards)
      /* VAO(0), VBO(0), EBO(0), texCoordVBO(0), shaderProgram(0), 
         hasTexture(false), speed(0.05f) */
{
}

Block::~Block() {
    // Only delete GL objects if they were actually generated by this instance
    // Note: If shaders/VAOs are shared, this needs careful management (e.g., reference counting)
    // For now, assume each block instance potentially creates its own.
    if (VAO != 0) glDeleteVertexArrays(1, &VAO);
    if (VBO != 0) glDeleteBuffers(1, &VBO);
    if (EBO != 0) glDeleteBuffers(1, &EBO);
    if (texCoordVBO != 0) glDeleteBuffers(1, &texCoordVBO);
    // Shaders are shared via ID, don't delete here unless this instance owns it.
    // if (shaderProgram != 0) glDeleteProgram(shaderProgram);
}

void Block::init() {
    // Compile shader only if not already done (e.g., by representative block)
    if (shaderProgram == 0) { 
        shaderProgram = compileShader(vertexShaderSource, fragmentShaderSource);
    }

    // Create buffers only if not already done
    if (VAO == 0) {
        // Set up vertex data for a cube
        float halfSize = size / 2.0f;
        float vertices[] = {
            // Positions          
            // Front face
            -halfSize, -halfSize,  halfSize,
             halfSize, -halfSize,  halfSize,
             halfSize,  halfSize,  halfSize,
            -halfSize,  halfSize,  halfSize,
            // Back face
            -halfSize, -halfSize, -halfSize,
             halfSize, -halfSize, -halfSize,
             halfSize,  halfSize, -halfSize,
            -halfSize,  halfSize, -halfSize
            // ... (Add other faces if needed for single block rendering, 
            //      but mesh builder uses simpler face data)
        };

        float texCoords[] = {
            // Front face
            0.0f, 0.0f,
            1.0f, 0.0f,
            1.0f, 1.0f,
            0.0f, 1.0f,
            // Back face
            1.0f, 0.0f,
            0.0f, 0.0f,
            0.0f, 1.0f,
            1.0f, 1.0f
            // ... (Tex coords for other faces)
        };

        unsigned int indices[] = {
            // Front face
            0, 1, 2, 2, 3, 0,
            // Back face
            4, 5, 6, 6, 7, 4
            // ... (Indices for other faces)
        };

        glGenVertexArrays(1, &VAO);
        glGenBuffers(1, &VBO);
        glGenBuffers(1, &EBO);
        // glGenBuffers(1, &texCoordVBO); // Tex coords can be interleaved

        glBindVertexArray(VAO);

        // VBO for positions (simplified for example)
        glBindBuffer(GL_ARRAY_BUFFER, VBO);
        glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
        glEnableVertexAttribArray(0);

        // VBO for tex coords (simplified)
        // If interleaved: Change vertex attrib pointer stride and offset
        // glBindBuffer(GL_ARRAY_BUFFER, texCoordVBO);
        // glBufferData(GL_ARRAY_BUFFER, sizeof(texCoords), texCoords, GL_STATIC_DRAW);
        // glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(float), (void*)0);
        // glEnableVertexAttribArray(1);

        // EBO
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
        glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);

        glBindBuffer(GL_ARRAY_BUFFER, 0);
        glBindVertexArray(0);
    }
}

// Renders this single block instance
void Block::render(const glm::mat4& projection, const glm::mat4& view) {
    if (VAO == 0) init(); // Ensure initialized
    if (VAO == 0 || shaderProgram == 0) return; // Initialization failed?

    useBlockShader();
    bindBlockTexture(); // Bind texture if it has one
    
    // Calculate model matrix specific to this block instance
    glm::mat4 model = glm::translate(glm::mat4(1.0f), position);
    
    setShaderUniforms(projection, view, model);

    // Draw the single block (using its own simple VAO)
    glBindVertexArray(VAO);
    // TODO: Adjust index count based on actual VAO setup in init()
    glDrawElements(GL_TRIANGLES, 12, GL_UNSIGNED_INT, 0); // Assuming 2 faces for example
    glBindVertexArray(0);
    Texture::unbind();
}

bool Block::loadTexture(const std::string& texturePath) {
    // Texture loading now uses the member texture object
    if (texture.loadFromFile(texturePath)) {
        hasTexture = true;
        return true;
    }
    // std::cerr << "Using default block color instead of texture." << std::endl;
    hasTexture = false;
    return false;
}

bool Block::loadTexture(const std::string& spritesheetPath, int atlasX, int atlasY, int atlasWidth, int atlasHeight) {
    bool success = texture.loadFromSpritesheet(spritesheetPath, atlasX, atlasY, atlasWidth, atlasHeight);
    hasTexture = success;
    return success;
}

// Share texture AND shader program ID from another block
void Block::shareTextureAndShaderFrom(const Block& other) {
    texture = other.texture; // Texture assignment operator handles sharing
    hasTexture = other.hasTextureState(); 
    shaderProgram = other.getShaderProgram();
}

void Block::move(float dx, float dy, float dz) {
    position.x += dx * speed;
    position.y += dy * speed;
    position.z += dz * speed;
}

void Block::setPosition(const glm::vec3& newPosition) {
    position = newPosition;
}

glm::vec3 Block::getPosition() const {
    return position;
}

glm::vec3 Block::getColor() const {
    return color;
}

// Activate the shader program for this block type
void Block::useBlockShader() const {
    if (shaderProgram != 0) {
        glUseProgram(shaderProgram);
    } // No warning here, expected that shader might be 0 if not initialized
}

// Bind the texture for this block type
void Block::bindBlockTexture() const {
    if (hasTexture) {
        texture.bind(0); // Bind to texture unit 0
    }
}

// Set common shader uniforms (projection, view, model)
void Block::setShaderUniforms(const glm::mat4& projection, const glm::mat4& view, const glm::mat4& model) const {
     if (shaderProgram == 0) {
         // This might happen if init() wasn't called or failed
         // std::cerr << "Warning: setShaderUniforms called with uninitialized shader." << std::endl;
         return;
     }
     
     glUniformMatrix4fv(glGetUniformLocation(shaderProgram, "model"), 1, GL_FALSE, glm::value_ptr(model));
     glUniformMatrix4fv(glGetUniformLocation(shaderProgram, "view"), 1, GL_FALSE, glm::value_ptr(view));
     glUniformMatrix4fv(glGetUniformLocation(shaderProgram, "projection"), 1, GL_FALSE, glm::value_ptr(projection));

     // Texture related uniforms
     glUniform1i(glGetUniformLocation(shaderProgram, "useTexture"), hasTexture);
     if (hasTexture) {
         glUniform1i(glGetUniformLocation(shaderProgram, "blockTexture"), 0); // Texture unit 0
     } else {
         // Pass the block's color if not using texture
         glUniform3fv(glGetUniformLocation(shaderProgram, "blockColor"), 1, glm::value_ptr(color));
     }
}

// Compiles shaders and links them into a program.
unsigned int Block::compileShader(const char* vShaderSource, const char* fShaderSource) {
    // ... (Shader compilation logic remains the same) ...
    GLuint vertexShader = glCreateShader(GL_VERTEX_SHADER);
    glShaderSource(vertexShader, 1, &vShaderSource, NULL);
    glCompileShader(vertexShader);
    // Check errors...
    int success;
    char infoLog[512];
    glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &success);
    if (!success) {
        glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);
        std::cerr << "ERROR::SHADER::VERTEX::COMPILATION_FAILED\n" << infoLog << std::endl;
        glDeleteShader(vertexShader);
        return 0;
    }

    GLuint fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
    glShaderSource(fragmentShader, 1, &fShaderSource, NULL);
    glCompileShader(fragmentShader);
    // Check errors...
    glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &success);
    if (!success) {
        glGetShaderInfoLog(fragmentShader, 512, NULL, infoLog);
        std::cerr << "ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n" << infoLog << std::endl;
        glDeleteShader(vertexShader); // Clean up vertex shader too
        glDeleteShader(fragmentShader);
        return 0;
    }

    GLuint program = glCreateProgram();
    glAttachShader(program, vertexShader);
    glAttachShader(program, fragmentShader);
    glLinkProgram(program);
    // Check errors...
    glGetProgramiv(program, GL_LINK_STATUS, &success);
    if (!success) {
        glGetProgramInfoLog(program, 512, NULL, infoLog);
        std::cerr << "ERROR::SHADER::PROGRAM::LINKING_FAILED\n" << infoLog << std::endl;
    }

    glDeleteShader(vertexShader);
    glDeleteShader(fragmentShader);

    return program;
}
